まずは正の得点を取りに行きたい

Powerを固定して(Cの値によって、固定値を変える)最短経路で掘ってみる(bfs, dijkstra)
C:{1, 2, 4, 8, 16, 32, 64, 128}
P:{10, 50, 100, 200, 300, 400, 600, 1000}


勾配になっている→微分みたいな方法で緩やかな方向を見つけられる？
5マスくらい離れたところを周囲8マス掘削すれば大体の勾配が分かり進む方向を決められる？
f(now) - f(remote) < 0 岩盤は固くなってる
f(now) - f(remote) > 0 岩盤はゆるくなってる(掘りやすい)

間隔空けて試し掘り→線形補間で大体のSが出せるはず
そのSを元にdijkstraをして最短経路を求める
更に出力する時にまたおおよそ正しいSの値が分かるから、その値とほぼ確定済みの値を上下左右4方向の中から見つけ、線形補間を更新(ただし、探索範囲には制限を付ける 10マス以内までみたいな)
最初10マスでやってみる

開けて10個くらいか...？
何マス破壊することになるか調べる
水源や家の周辺の岩盤だけ調べればいいはずで必要になったら岩盤開ける

最後に必要な水源だけ開ける 家と水源がある場所は柔らかいから先に割ったほうが良い

まず家と水の岩盤は開ける→これは全てで共通になるはず
家構造体を作って、
id、座標、path(dequeで)、targetの水源などを持たせる

掘削するたびにSを更新するのが重要らしい

はじめに家と水を全部割る
↓
試し掘削をする
↓
線形補間をする
↓
家と水の位置の情報を用いて線形補間やり直し

最初のRow、Colのidxのvector
と
各行、各列のRow、Colのidxのvectorを持つ
これによりlower_boundとupper_boundで上と下、右と左を簡単に探索することが出来る
最初のRow、Colより近くに既に調査済みのSがあればそれを使い、そうでなければ最初に掘削した際の線形補間の情報を用いる
ある位置の強度が決定した時に、その周囲の更新をする関数を作成しておく
掘削するごとに更新するのが大切そう
→
すなわち各家を順番に1回ずつ回るのが更新が有効的になりそうな気がする

線形補間をした後は、開けた位置のSは0にする

家が近い場合に無駄な掘削が発生しているから、水源から到達できるセルからの最短経路を求める？

今日最低限やること
試し堀り
線形補間
(できれば)cubic補間

updateは単純にbilinearとかcubicではなくて何か別の方法を考える？もしくは周囲画素を適当に選んで近い範囲だけbilinearやbicubicで補間をする
とりあえずupdateの実装は一番最後になる

bilinearはそれっぽい形になってそう
次cubicを試してみたい

あとmain logicも直す価値ありそう
  pathをreverseして水源から掘り始める
水源が複数あるときに何故か一つの水源しか使わず、遠回りしているのは明らかに損していそう
コストの計算が間違ってて全て最後の水源になってるとか？

とりあえずcubicより前にmain logicの修正を掛けてみる
  calculateInitialShortestPath() これはおけ
  とmain logic
  今の所updateは考えていないから、各家順番に処理していく
  水源から破壊
  コストが小さい家の方から処理していく
  estimateS_との差を見て、差があまりにも大きかったらSの値を修正したい
  どうやって？

競プロ用行列ライブラリを整備した方が良さそう




推定してるんだから出来るだけ1発で壊してしまえばいい
最初の一発は推定値から思い切り壊して、2発目から慎重に壊せば良い気がする
  なぜかうまく行かない、とりあえずここは後回しでもいいかも

mapToCの値試し掘削のときと、本掘削のときで値を変えるのも大事そう

